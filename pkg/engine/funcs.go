package engine

import (
	"fmt"
	"math/big"
	"math/rand"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
)

var prngs = make(map[string]*rand.Rand)

func funcMap(t *template.Template) template.FuncMap {
	f := sprig.TxtFuncMap()
	includedNames := make(map[string]int)

	// Custom template functions
	f["include"] = includeFun(t, includedNames)
	f["stableRandomAlphanumeric"] = stableRandomAlphanumeric

	return f
}

const lowerAlpha = "abcdefghijlkmnopqrstuvwxyz"
const number = "0123456789"
const alphanumeric = lowerAlpha + number
const recursionMaxNums = 100

// Generate a pseudo-random alphanumeric string of the given length
// such that the sequence of strings generated by successive calls
// is the same for a given string.
func stableRandomAlphanumeric(length int, str string) string {
	p := prngForStr(str)
	chars := make([]byte, length)
	for i := 0; i < length; i++ {
		chars[i] = alphanumeric[p.Intn(len(alphanumeric))]
	}
	return string(chars)
}

// Get the PRNG for the given string, by either seeding a new one
// or returning a previously seeded one.
func prngForStr(str string) *rand.Rand {
	p, ok := prngs[str]
	if !ok {
		i := big.NewInt(0)
		i.SetString(strings.ReplaceAll(str, "-", ""), 16)
		seed := big.NewInt(0)
		// We throw away half of the bits of the UUID here with the Rsh
		// but probably it's still ok?
		p = rand.New(rand.NewSource(seed.Rsh(i, 1).Int64()))
		prngs[str] = p
	}
	return p
}

// Reset generated PRGNs.
func resetRngs() {
	prngs = make(map[string]*rand.Rand)
}

func includeFun(t *template.Template, includedNames map[string]int) func(string, interface{}) (string, error) {
	return func(name string, data interface{}) (string, error) {
		var buf strings.Builder
		if v, ok := includedNames[name]; ok {
			if v > recursionMaxNums {
				return "", fmt.Errorf("unable to execute template: maximum recursion depth reached for template block \"%s\"", name)
			}
			includedNames[name]++
		} else {
			includedNames[name] = 1
		}
		err := t.ExecuteTemplate(&buf, name, data)
		includedNames[name]--
		return buf.String(), err
	}
}
